---
import FullScreenable from "../../components/FullScreenable.svelte";
import MasonryImageGrid from "../../components/MasonryImageGrid.svelte";
import { Image } from "astro:assets";
import { projectData } from "../../lib/getProjects";
import { parse, HTMLElement, Node } from "node-html-parser";

export function getStaticPaths() {
  return projectData.map((project) => ({
    params: { slug: project.slug },
  }));
}

import { getProjectBySlug, type ProjectData } from "../../lib/getProjects";
import Layout from "../../layouts/Layout.astro";

const { slug } = Astro.params;
const project: ProjectData = getProjectBySlug(slug)!;
console.debug("Project is", project);

if (!project) {
  console.error("Project not found!", slug);
}

// Process image sources in the HTML content
let processedHtml = project.descriptionHtml;
const imagesSrcRegex = /src="\.\/([^"]+)"/g;
const matches = project.descriptionHtml.match(imagesSrcRegex) || [];
await Promise.all(
  matches.map(async (match) => {
    const imageSrc = match.replace(imagesSrcRegex, "$1");
    const image = project.images.find((i) =>
      i.name.endsWith(imageSrc.slice(1, imageSrc.length))
    ); // remove first dot
    if (image) {
      processedHtml = processedHtml.replace(
        match,
        `src="${(await image()).default.src}"`
      );
    }
  })
);

// Filter images that don't start with underscore for the additional images section
let imagesToShow = project.images.filter(
  (img) => !img.name.split("/").pop()!.startsWith("_")
);

// Define section types
type Section =
  | {
      type: "html";
      html: string;
    }
  | {
      type: "masonry-image-grid";
      height: string;
      width: string;
      images: (() => Promise<{ default: ImageMetadata }>)[];
      smColumns?: number;
      mdColumns?: number;
      lgColumns?: number;
    }
  | {
      type: "single-image";
      src: (() => Promise<{ default: ImageMetadata }>);
      height: string;
      maxHeight: string;
      maxWidth: string;
      width: string;
      alt: string;
    };

function getAndDisplaceProjectImage(...imageNames: string[]) {
  const images = project.images.filter((img) => {
              const imgFileName = img.name.split("/").pop()!;
              return imageNames.includes(imgFileName);
            });

  // Remove these images from imagesToShow
  imagesToShow = imagesToShow.filter((img) => !images.includes(img));
  return images;
}

/**
 * Parse HTML content into sections
 * This uses a proper HTML parser instead of regex for more robust handling
 */
function parseIntoSections(html: string): Section[] {
  const sections: Section[] = [];

  try {
    // First, convert single Image tags to Images tags for consistency
    const root = parse(html);

    // Process all Image tags and convert them to Images tags
    // root.querySelectorAll('single-image').forEach((imageTag: HTMLElement) => {
    //   try {
    //     const src = imageTag.getAttribute('src');
    //     const width = imageTag.getAttribute('width');
    //     const height = imageTag.getAttribute('height');

    //     if (src) {
    //       const imagesTag = parse(`<Images images="${src}" width="${width || '300'}" height="${height || '300'}" smColumns="1" mdColumns="1" lgColumns="1" />`);
    //       imageTag.replaceWith(imagesTag);
    //     }
    //   } catch (error) {
    //     console.error('Error processing Image tag:', error);
    //   }
    // });

    // Get the modified HTML
    const modifiedHtml = root.toString();

    // Now parse the HTML into sections
    const parsedRoot = parse(modifiedHtml);
    const childNodes = [...parsedRoot.childNodes];

    let currentHtmlSection = "";

    for (let i = 0; i < childNodes.length; i++) {
      const node = childNodes[i];

      if (
        node.nodeType === 1 &&
        (node as HTMLElement).tagName === "SINGLE-IMAGE"
      ) {
        // If we have accumulated HTML content, add it as an HTML section
        if (currentHtmlSection.trim()) {
          sections.push({
            type: "single-image",
            // src: (node as HTMLElement).getAttribute("src") || "",
            src: getAndDisplaceProjectImage(
              (node as HTMLElement).getAttribute("src") || ""
            )[0],
            maxWidth: (node as HTMLElement).getAttribute("max-width") || "100%",
            maxHeight:
              (node as HTMLElement).getAttribute("max-height") || "100%",
            width: (node as HTMLElement).getAttribute("width") || "100%",
            height: (node as HTMLElement).getAttribute("height") || "100%",
            alt: (node as HTMLElement).getAttribute("alt") || "",
          });
        }
      }

      // Check if this is an Images tag
      if (node.nodeType === 1 && (node as HTMLElement).tagName === "IMAGES") {
        // If we have accumulated HTML content, add it as an HTML section
        if (currentHtmlSection.trim()) {
          sections.push({
            type: "html",
            html: currentHtmlSection.trim(),
          });
          currentHtmlSection = "";
        }

        try {
          // Extract attributes from the Images tag
          const element = node as HTMLElement;
          const imagesAttr = element.getAttribute("images");
          const heightAttr = element.getAttribute("height");
          const widthAttr = element.getAttribute("width");
          const smColumnsAttr = element.getAttribute("smColumns");
          const mdColumnsAttr = element.getAttribute("mdColumns");
          const lgColumnsAttr = element.getAttribute("lgColumns");

          if (imagesAttr) {
            const imageNames = imagesAttr
              .split(",")
              .map((img: string) => img.trim());

            // Add the masonry image grid section
            sections.push({
              type: "masonry-image-grid",
              height: heightAttr || "400px",
              width: widthAttr || "100%",
              images: getAndDisplaceProjectImage(...imageNames),
              smColumns: smColumnsAttr ? parseInt(smColumnsAttr) : undefined,
              mdColumns: mdColumnsAttr ? parseInt(mdColumnsAttr) : undefined,
              lgColumns: lgColumnsAttr ? parseInt(lgColumnsAttr) : undefined,
            });
          }
        } catch (error) {
          console.error("Error processing Images tag:", error);
          // If there's an error, just add the node as HTML
          currentHtmlSection += node.toString();
        }
      } else {
        // For other nodes, accumulate HTML content
        currentHtmlSection += node.toString();
      }
    }

    // Add any remaining HTML content
    if (currentHtmlSection.trim()) {
      sections.push({
        type: "html",
        html: currentHtmlSection.trim(),
      });
    }
  } catch (error) {
    console.error("Error parsing HTML:", error);
    // Fallback: return the entire HTML as a single section
    sections.push({
      type: "html",
      html: html,
    });
  }

  return sections;
}

const parsedSections = parseIntoSections(processedHtml);
console.log("PARSED SECTIONS", parsedSections);
---

<Layout>
  <div class="prose max-w-[80ch]">
    <!-- <p><a href="/portfolio" class="no-underline">‚Üê Back</a></p> -->
    <span>{project.category.title} - {project.year}</span>
    <h1 class="font-serif text-5xl">{project.title}</h1>
    <!-- Use Astro's dangerouslySetInnerHTML for the pre-parsed HTML from Markdown -->
    <!-- <div set:html={project.descriptionHtml} /> -->
    {
      parsedSections.map(async (section, index) => {
        switch (section.type) {
          case "html":
            return <div set:html={section.html} id={`section-${index}`} />;
          case "single-image":
            return (
              <div id={`section-${index}`} class="relative">
                <FullScreenable src={section.src()} client:load>
                  <div slot="image">
                    <Image
                      src={section.src()}
                      alt={section.alt}
                      width={parseInt(section.width) || 300}
                      height={parseInt(section.height) || 300}
                      style={`max-width: ${section.maxWidth}; max-height: ${section.maxHeight};`}
                    />
                  </div>
                  <div slot="full-screen">
                    <Image src={section.src()} alt="Project image" />
                  </div>
                </FullScreenable>
              </div>
            );
          case "masonry-image-grid":
            return (
              <div
                class="image-grid grid relative max-w-[80ch]"
                id={`section-${index}`}
                style={`--smColumns: ${section.smColumns || 2}; --mdColumns: ${section.mdColumns || 3}; --lgColumns: ${section.lgColumns || 3};`}
              >
                {section.images.map(async (img) => (
                  <div class="" data-masonry-item>
                    <FullScreenable src={await img()} client:load>
                      <div slot="image">
                        <Image
                          src={img()}
                          alt="Project image"
                          width={parseInt(section.width) || 300}
                          height={parseInt(section.height) || 300}
                        />
                      </div>
                      <div slot="full-screen">
                        <Image src={img()} alt="Project image" />
                      </div>
                    </FullScreenable>
                  </div>
                ))}
              </div>
            );
        }
      })
    }
  <!-- <div class="w-full h-full"> -->
  <MasonryImageGrid>
    {
      imagesToShow.map(async (img) => (
        <div class="max-w-[250px]" data-masonry-item>
          <FullScreenable client:load src={await img()}>
            <div slot="image">
              <Image
                src={img()}
                alt="Additional project image"
                width={300}
                height={300}
              />
            </div>
            <div slot="full-screen">
              <Image src={img()} alt="Additional project image" />
            </div>
          </FullScreenable>
        </div>
      ))
    }
  </MasonryImageGrid>
  </div>
</Layout>

<style>
  .image-grid {
    display: grid;
    grid-template-rows: 1;
    grid-template-columns: repeat(var(--smColumns), 1fr);
    gap: 1rem;
  }
  @media (min-width: 768px) {
    div.image-grid {
      grid-template-columns: repeat(var(--mdColumns), 1fr);
    }
  }
  @media (min-width: 1024px) {
    div.image-grid {
      grid-template-columns: repeat(var(--lgColumns), 1fr);
    }
  }
</style>
